
import { LogEntry } from '@/types';
import { mockLogs } from '@/data/mockLogs';

// This function simulates fetching logs from an API.
export const getLogs = async (): Promise<LogEntry[]> => {
  console.log("Fetching logs from mock API...");
  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 500));
  // Return a copy to avoid direct mutation issues with React strict mode
  const sortedLogs = [...mockLogs].sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
  console.log("Mock API responded with logs:", sortedLogs);
  return sortedLogs;
};


// This is a mock API function that simulates submitting a new log to a server.
export const submitLog = async (
  logData: { title: string; description: string }
): Promise<LogEntry> => {
  console.log("Submitting log to mock API:", logData);

  const { title, description } = logData;

  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 500));

  const newLog: LogEntry = {
    id: Date.now(),
    timestamp: new Date().toISOString(),
    author: 'Parent', // For now, we assume the parent is always the author of new logs.
    original_entry: {
      title: title,
      description: description,
    },
    // In a real app, these would be generated by our AI backend
    summary_for_teacher: `[AI Summary for Teacher]: Based on the parent's note about "${title}", please observe the child for related behaviors.`,
    summary_for_doctor: `[AI Summary for Doctor]: Patient's parent reports: "${title}". Description: "${description}".`,
    tags: ['new', 'manual entry'],
  };
  
  console.log("Mock API responded with new log:", newLog);
  // We'll prepend to the mockLogs array to simulate a database update.
  // In a real app, you wouldn't do this on the client.
  mockLogs.unshift(newLog); 
  return newLog;
};
